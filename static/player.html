<!doctype html>
<title>Player - Pictionary</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<html>

<head>

    <script src="socket.io.min.js"></script>
    <script src="socketlogic.js"></script>
    <script src="vue.js"></script>
    <script src="canvas.js"></script>
    </script>

</head>

<body>
    <div id="pictionaryapp">

        <div id='vue-app'>
            <canvas :class="{pausedCanvasStyle:paused}" id="pictionary" height="300" width="400">
            </canvas>
            <div class="timer">${timeleftMMSS}</div>
            <button @click="clearCanvas">clear screen</button>
            <button @click="teamsbtnsvisible = !teamsbtnsvisible; paused = !paused">guessed!</button>
            <div v-if="teamsbtnsvisible" class="submenu">
                <button v-for="team in teams" @click="pointGoesTo(team)">
                    ${team.name}
                </button>
            </div>
            <!-- <button @click="settings">settings</button> -->
            <button @click="timeSettingVisible = !timeSettingVisible">settime</button>
            <div v-if="timeSettingVisible" class="submenu">
                <input v-model="options_roundTime" @keyup.enter="timeSettingVisible = false">360</input>
                <button @click="timeSettingVisible = false">done</button>
            </div>

            <button @click="addTeamVisible = !addTeamVisible">addTeam</button>
            <div v-if="addTeamVisible" class="submenu">
                <br>team name:</input><input v-model="newTeam.name"></input>
                <button @click="addNewTeam">done</button>
            </div>


            <button @click="addPlayerVisible = !addPlayerVisible">addPlayer</button>
            <div v-if="addPlayerVisible" class="submenu">
                <button @click="selectteamsvisible = !selectteamsvisible">selectTeam</button>
                <div v-if="selectteamsvisible" class="teamsbtns">
                    <button v-for="team in teams" @click="selectTeamForNewPlayer(team)">
                        ${team.name}
                    </button>
                </div>
                <div v-else>select team first
                    <!-- <div v-if="newPlayer.teamId != -1">
                            ${this.teams[newPlayer.teamId].name}</div>
                    </div v-else> no team selected</div> -->
                </div>
                <br>Player name:<input v-model="newPlayer.name"></input>
                <br>Player picture:<input v-model="newPlayer.picture"></input>
                <button @click="addNewPlayer">done</button>
            </div>


            <button v-if="!gameStarted" @click="startGame">start game</button>
            <button v-if="!paused" @click="pause">pause</button>
            <button v-if="paused" @click="unpause">unpause</button>


            <div v-if="nextPlayerMessageVisible" class="nextPlayerMessageModal">

                <img :src="currentplayer.picture">
                Player ${currentplayer.name} turn. Please press continue.
                <button @click="nextPlayerConfirmed">Continue</button>
            </div>
            <div v-if="msgvisible" class="submenu">
                MESSAGE: <br>
                ${textShownMsg}
                <button @click="msgvisible = false">OK</button>
            </div>

        </div>

    </div>
    <script>
        /*Vue.component(id, [definition])


            what if time is up and nobody guesses?
            pressing guessed sets some value to true
            and this value is checked always when nextplayer funcions are run*/

        function TeamsFactory(initialId = 0) {
            this.nextId = initialId;
            this.teams = [];
        }

        function Team(ob) {
            this.name = ob.name,
                this.id = ob.id,
                this.players = ob.players,
                this.points = ob.points
        }

        Team.prototype.jso = function () {
            return {
                name: this.name,
                id: this.id,
                points: this.points
            }
        }
        TeamsFactory.prototype.createTeam = function (ob) {
            let t = new Team({
                name: ob.name,
                id: this.nextId++,
                players: ob.players,
                points: ob.points
            })
            this.teams.push(t);
            return t;
        }

        function PlayersFactory(initialId = 0) {
            this.nextId = initialId;
            this.players = [];
        }

        function Player(ob) {
            this.id = ob.id,
                this.name = ob.name,
                this.picture = ob.picture,
                this.teamId = ob.teamId;
        }
        Player.prototype.jso = function () {
            return {
                name: this.name,
                id: this.id,
                picture: this.picture,
                teamId: this.teamId
            }
        }

        PlayersFactory.prototype.createPlayer = function (ob) {
            let p = new Player(ob)
            p.picture = ob.picture ? ob.picture : "nopicture.png";
            p.id = this.nextId++
            this.players.push(p)
            return p
        }


        var teamsFactory = new TeamsFactory(0);
        var playersFactory = new PlayersFactory(0);

        DefTeams = [{
                name: "Druzyna A",
                players: [],
                points: 0
            },
            {
                name: "Druzyna RR",
                players: [],
                points: 0
            }
        ]
        DefPlayers = [{
                name: 'Bolek',
                picture: ``,
                teamId: 0,
            },
            {
                name: 'Ania',
                picture: ``,
                teamId: 1,
            },

            {
                name: 'Maurycy',
                picture: ``,
                teamId: 1,
            },

            {
                name: 'Piotrek',
                picture: ``,
                teamId: 0,
            },
        ];

        function awardGuesser(chosenTeam) {
            ++chosenTeam.points; //this could be done with vue on screen cli
            send_score_update(chosenTeam) // if packet is not send back to author
        }

        function zeroPadding(num, digit) {
            var zero = '';
            for (var i = 0; i < digit; i++) {
                zero += '0';
            }
            return (zero + num).slice(-digit);
        }

        function initCanvasAndSocketIO() {
            // Get the specific canvas element from the HTML document
            canvas = document.getElementById('pictionary');

            // If the browser supports the canvas tag, get the 2d drawing context for this canvas
            if (canvas.getContext)
                ctx = canvas.getContext('2d');

            // Check that we havme a valid context to draw on/with before adding event handlers
            if (ctx) {
                // React to mouse events on the canvas, and mouseup on the entire document
                canvas.addEventListener('mousedown', pictionary_mouseDown, false);
                canvas.addEventListener('mousemove', pictionary_mouseMove, false);
                window.addEventListener('mouseup', pictionary_mouseUp, false);

                // React to touch events on the canvas
                canvas.addEventListener('touchstart', pictionary_touchStart, false);
                canvas.addEventListener('touchend', pictionary_touchEnd, false);
                canvas.addEventListener('touchmove', pictionary_touchMove, false);
                initSocketIO('player') // function in socketlogic.js
            }
        };

        v = new Vue({
            delimiters: ['${', '}'], // to avoid clash with Jinja2 moustaches
            el: '#vue-app',
            data: {
                timerID: null,
                gameStarted: false,

                addTeamVisible: false,
                addPlayerVisible: false,
                timeSettingVisible: false,
                selectteamsvisible: false,
                teamsbtnsvisible: false,
                nextPlayerMessageVisible: false,
                newTeam: {
                    name: "",
                    players: [],
                    points: 0
                },
                newPlayer: {
                    name: '',
                    picture: ``,
                    teamId: null,
                },
                teamThatWon: null,
                menuopened: false,
                socket: null,
                paused: false,
                teams: teamsFactory.teams,
                players: playersFactory.players,
                fullMesh: fullMesh,
                timeleft: null,
                c_options_roundTime: 20,
                currentplayer: null,
                currentplayerindex: null,
                alert: true,
                msgvisible: false,
                textShownMsg: '',

            }, // end of data
            mounted() {
                initCanvasAndSocketIO()
                this.socket = socket // this is if html served from python not from external cloud
                // in case of external site this site must know what ip address of Game Master is

                onDrawDotEventHandler = (x, y, fingerup) => {
                    this.onDrawDotEventHandler(x, y, fingerup)
                }
                this.autoTeamList();
                socket.on('welcome_new_player', (socketmsg) => {
                    console.log(`welcome new player , connections amount: ${socketmsg.data}`);
                    9
                })
            }, // end of mounted
            watch: {
                timeleft(nuVal) {
                    if (nuVal === 0) {
                        this.onTimesUp();
                    }
                }
            },
            computed: {
                timeleftMMSS() {
                    let mins = this.timeleft % (60 * 60);
                    let minutes = Math.floor(mins / 60);

                    let secd = mins % 60;
                    let seconds = Math.ceil(secd);
                    if (seconds < 10) {
                        seconds = `0${seconds}`;
                    }
                    return `${minutes}:${seconds}`;
                },
                options_roundTime: {
                    set(val) {
                        this.c_options_roundTime = parseInt(val);
                        socket.emit("options_roundTime", {
                            data: this.options_roundTime
                        })
                    },
                    get() {
                        return this.c_options_roundTime;
                    }
                },
            }, // end of computed
            methods: {
                startGame() {
                    if (!(this.players.length > 0 && this.teams.length > 1)) {
                        this.showMsg('not enough players and teams !!')
                        return;
                    }
                    if (!this.gameStarted) {
                        this.gameStarted = true;
                        this.currentplayerindex = -1;
                        this.next_player();
                    };
                },
                startTimer() {
                    this.paused = false;
                    this.timerID = setInterval(() => {
                        if (!this.paused) {
                            this.timeleft -= 1
                        }
                    }, 1000);
                },
                onTimesUp() {
                    clearInterval(this.timerID);
                    this.next_player();
                },
                selectTeamForNewPlayer(team) {
                    this.newPlayer.teamId = team.id;
                    this.selectteamsvisible = false;
                    this.showMsg("selected team")
                },
                autoTeamList() {
                    DefTeams.forEach(team => {
                        this.newTeam = team;
                        this.addNewTeam();
                    })

                    DefPlayers.forEach(player => {
                        this.newPlayer = player;
                        this.addNewPlayer();
                    })
                },
                unpause() {
                    this.paused = false;
                    socket.emit('unpause', {
                        data: 1
                    })
                },
                showMsg(msg, alert = true) {
                    this.alert = alert;
                    this.msgvisible = true;
                    this.textShownMsg = msg;
                },
                addNewTeam() {
                    if (this.newTeam.name.length < 1) {
                        this.showMsg('please give a name')
                    }
                    this.addTeamVisible = false;
                    let nuTeam = teamsFactory.createTeam(this.newTeam)

                    socket.emit('addNewTeam', {
                        data: nuTeam.jso()
                    })
                    this.showMsg('new team created: ' + nuTeam.name);
                    this.newTeam = {
                        name: "",
                        players: [],
                        points: 0
                    };
                },
                addNewPlayer() {
                    if (this.newPlayer.name.length < 1) {
                        this.showMsg('please give a name')
                    }
                    if (this.newPlayer.teamId === -1) {
                        this.showMsg('please select a team')
                    }
                    this.addPlayerVisible = false;
                    let nuPlayer = playersFactory.createPlayer(this.newPlayer);
                    let plrTeamId = this.newPlayer.teamId
                    let plrTeam = this.teams[plrTeamId]
                    plrTeam.players.push(
                        nuPlayer); // dont f9rget to push him to teh team on the screen side
                    // how to send new Player's team over socket, without circular dependencies ? 
                    // try to assign id (array index)
                    socket.emit('addNewPlayer', {
                        data: nuPlayer.jso()
                    });
                    this.showMsg(
                        'new player:' + nuPlayer.name +
                        ' created in team:' + plrTeam.name);
                    this.newPlayer = {
                        name: "",
                        picture: 'nopicture.png',
                        teamId: -1
                    };
                },
                onDrawDotEventHandler(x, y, fingerup) {
                    console.log(x, y, fingerup);
                    this.fullMesh.push({
                        x: x,
                        y: y,
                        fingerup: fingerup
                    })
                    socket.emit('player_drawn_new_line', {
                        data: {
                            x: x,
                            y: y,
                            fingerup: fingerup
                        }
                    });
                },
                pointGoesTo(team) {
                    this.teamsbtnsvisible = false;
                    team.points++;
                    this.next_player();
                    socket.emit('pointGoesTo', {
                        data: team.id
                    })
                },
                savePictureToDB() {
                    let mesh = JSON.stringify(this.fullMesh);
                    socket.emit('savePicture', {
                        data: mesh,
                    })
                },
                next_player() {
                    this.savePictureToDB();
                    // cycle through players(teams)array
                    this.clearCanvas();
                    this.resetClock();
                    this.currentplayerindex = this.currentplayerindex === this.players.length - 1 ?
                        0 : this.currentplayerindex + 1;
                    this.currentplayer = this.players[this.currentplayerindex];
                    this.showNextPlayerMessage();
                },
                showNextPlayerMessage() {
                    this.pause();
                    this.nextPlayerMessageVisible = true;
                },
                nextPlayerConfirmed(socketmsg) {
                    this.nextPlayerMessageVisible = false;
                    this.startTimer();
                },
                resetClock() {
                    this.timeleft = this.options_roundTime;
                },
                pause() {
                    this.paused = true; //stops clock and canvas
                    socket.emit("paused", {
                        data: 'paused'
                    });
                },

                clearCanvas() {
                    // call canvas api
                    // function
                    clearCanvas()
                    this.send_clear()
                },
                send_clear() {
                    socket.emit("clear", {
                        data: 'clear'
                    });
                    //  this.saveDrawingToDB(); //should be done byscreen or server 
                },

            }, // end of methods
        }); // end of new Vue
    </script>
    </div>
</body>






<style>
    body,
    html {
        margin: 0px;
        padding: 0px;
    }

    .submenu {
        border: 2px solid #888;
        background-color: aliceblue;
        padding: 5px;
        margin: 5px;
    }


    #pictionaryapp {
        /* Prevent nearby text being highlighted when accidentally dragging mouse outside confines of the canvas */
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
    }



    #pictionary {
        height: 300px;
        width: 400px;
        border: 2px solid #888;
        border-radius: 4px;
        position: relative;
        /* Necessary for correct mouse co-ords in Firefox */
    }

    .pausedCanvasStyle {
        opacity: 0.3;
        pointer-events: none;
        background-color: gray;
    }
</style>

</html>